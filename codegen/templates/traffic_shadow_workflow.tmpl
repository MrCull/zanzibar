{{/* template to render gateway workflow interface code */ -}}
{{- $instance := .Instance }}
package workflow

{{- $endpointType := .Spec.EndpointType }}
{{- $reqHeaderMap := .ReqHeaders }}
{{- $reqHeaderMapKeys := .ReqHeadersKeys }}
{{- $defaultHeaders := .DefaultHeaders }}
{{- $reqHeaderRequiredKeys := .ReqRequiredHeadersKeys }}
{{- $resHeaderMap := .ResHeaders }}
{{- $resHeaderMapKeys := .ResHeadersKeys }}
{{- $clientID := .ClientID }}
{{- $clientName := title .ClientName }}
{{- $clientMethodName := title .ClientMethodName }}
{{- $serviceMethod := printf "%s%s" (title .Method.ThriftService) (title .Method.Name) }}
{{- $workflowInterface := printf "%sWorkflow" $serviceMethod }}
{{- $workflowStruct := camel $workflowInterface }}
{{- $trafficShadowingEnabled := .IsTrafficShadowingEnabled }}
{{- $trafficShadowClientID := .TrafficShadowClientID }}
{{- $trafficShadowClientName := .TrafficShadowClientName }}
{{- $trafficShadowClientMethod := .TrafficShadowClientMethod }}

import (
	"context"
	"net/textproto"
	"github.com/uber/zanzibar/config"

	zanzibar "github.com/uber/zanzibar/runtime"

	{{range $idx, $pkg := .IncludedPackages -}}
	{{$pkg.AliasName}} "{{$pkg.PackageName}}"
	{{end -}}

	{{if .Method.Downstream }}
	{{- range $idx, $pkg := .Method.Downstream.IncludedPackages -}}
	{{$file := basePath $pkg.PackageName -}}
	{{$pkg.AliasName}} "{{$pkg.PackageName}}"
	{{end}}
	{{- end}}

	{{if .Method.ShadowDownstream }}
	{{- range $idx, $pkg := .Method.ShadowDownstream.IncludedPackages -}}
	{{$file := basePath $pkg.PackageName -}}
	{{$pkg.AliasName}} "{{$pkg.PackageName}}"
	{{end}}
	{{- end}}

	module "{{$instance.PackageInfo.ModulePackagePath}}"
	"go.uber.org/zap"
)

{{with .Method -}}
// {{$workflowInterface}} defines the interface for {{$serviceMethod}} workflow
type {{$workflowInterface}} interface {
Handle(
{{- if and (eq .RequestType "") (eq .ResponseType "") }}
	ctx context.Context,
	reqHeaders zanzibar.Header,
) (zanzibar.Header, error)
{{else if eq .RequestType "" }}
	ctx context.Context,
	reqHeaders zanzibar.Header,
) ({{.ResponseType}}, zanzibar.Header, error)
{{else if eq .ResponseType "" }}
	ctx context.Context,
	reqHeaders zanzibar.Header,
	r {{.RequestType}},
) (zanzibar.Header, error)
{{else}}
	ctx context.Context,
	reqHeaders zanzibar.Header,
	r {{.RequestType}},
) ({{.ResponseType}}, zanzibar.Header, error)
{{- end}}
}

{{end -}}

{{- if .Method.Downstream }}
{{- $method := .Method -}}
{{- with .Method -}}
{{- $methodName := title .Name }}
{{- $clientPackage := .Downstream.PackageName -}}
{{- $shadowClientPackage := .ShadowDownstream.PackageName -}}
{{- $clientMethod := .DownstreamMethod -}}
{{- $shadowClientMethod := .ShadowDownstreamMethod -}}
{{- $clientReqType := fullTypeName ($clientMethod).RequestType ($clientPackage) -}}
{{- $clientResType := fullTypeName  ($clientMethod).ResponseType ($clientPackage) -}}
{{- $shadowClientResType := fullTypeName  ($shadowClientMethod).ResponseType ($shadowClientPackage) -}}
{{- $clientExceptions := .DownstreamMethod.Exceptions -}}

// New{{$workflowInterface}} creates a workflow
func New{{$workflowInterface}}(deps *module.Dependencies) {{$workflowInterface}} {
	var whitelistedDynamicHeaders []string
	if deps.Default.Config.ContainsKey("clients.{{$clientID}}.alternates") {
		var alternateServiceDetail config.AlternateServiceDetail
		deps.Default.Config.MustGetStruct("clients.{{$clientID}}.alternates", &alternateServiceDetail)
		for _, routingConfig := range alternateServiceDetail.RoutingConfigs {
			whitelistedDynamicHeaders = append( whitelistedDynamicHeaders, textproto.CanonicalMIMEHeaderKey(routingConfig.HeaderName))
		}
	}

	return &{{$workflowStruct}}{
		Clients: deps.Client,
		Logger:  deps.Default.Logger,
		whitelistedDynamicHeaders: whitelistedDynamicHeaders,
	}
}

// {{$workflowStruct}} calls thrift client {{$clientName}}.{{$clientMethodName}}
type {{$workflowStruct}} struct {
	Clients *module.ClientDependencies
	Logger  *zap.Logger
	whitelistedDynamicHeaders []string
}

// Handle calls thrift client.
func (w {{$workflowStruct}}) Handle(
{{- if and (eq .RequestType "") (eq .ResponseType "") }}
	ctx context.Context,
	reqHeaders zanzibar.Header,
) (zanzibar.Header, error) {
{{else if eq .RequestType "" }}
	ctx context.Context,
	reqHeaders zanzibar.Header,
) ({{.ResponseType}}, zanzibar.Header, error) {
{{else if eq .ResponseType "" }}
	ctx context.Context,
	reqHeaders zanzibar.Header,
	r {{.RequestType}},
) (zanzibar.Header, error) {
{{else}}
	ctx context.Context,
	reqHeaders zanzibar.Header,
	r {{.RequestType}},
) ({{.ResponseType}}, zanzibar.Header, error) {
{{- end}}
	{{- if ne .RequestType "" -}}
	clientRequest := convertTo{{title .Name}}ClientRequest(r)
	{{end}}

	{{- if len $method.PropagateHeadersGoStatements | ne 0 }}
		{{- if ne .RequestType "" -}}
			clientRequest = propagateHeaders{{title .Name}}ClientRequests(clientRequest, reqHeaders)
		{{- else -}}
			clientRequest := propagateHeaders{{title .Name}}ClientRequests(nil, reqHeaders)
		{{end}}
	{{end}}

	clientHeaders := map[string]string{}
	{{if (ne (len $defaultHeaders) 0) }}
	var ok bool
	var h string
	var k string
	{{range $i, $k := $defaultHeaders}}
	k = textproto.CanonicalMIMEHeaderKey("{{$k}}")
	h, ok = reqHeaders.Get(k)
	if ok {
		clientHeaders[k] = h
	}

	{{- end -}}
	{{- end -}}

	{{if (ne (len $reqHeaderMapKeys) 0) }}
	{{if (eq (len $defaultHeaders) 0) }}
	var ok bool
	var h string
	{{- end -}}
	{{- end -}}
	{{range $i, $k := $reqHeaderMapKeys}}
	h, ok = reqHeaders.Get("{{$k}}")
	if ok {
		{{- $typedHeader := index $reqHeaderMap $k -}}
		clientHeaders["{{$typedHeader.TransformTo}}"] = h
	}
	{{- end}}
	for _, whitelistedHeader := range w.whitelistedDynamicHeaders {
		headerVal, ok := reqHeaders.Get(whitelistedHeader)
		if ok {
			clientHeaders[whitelistedHeader] = headerVal
		}
	}

	h, ok = reqHeaders.Get("X-Uber-Shadow-Client")

	resHeaders := zanzibar.ServerTChannelHeader{}
	if ok {
		clientRespBody, _, _ := w.Clients.{{$trafficShadowClientName}}.{{$trafficShadowClientMethod}}(
							ctx, clientHeaders,
						)
		response := convert{{.ShadowDownstreamService}}{{title .Name}}ClientResponse(clientRespBody)
			return response, resHeaders, nil
	} else {
		clientRespBody, _, _ := w.Clients.{{$clientName}}.{{$clientMethodName}}(
							ctx, clientHeaders,
						)
		response := convert{{.DownstreamService}}{{title .Name}}ClientResponse(clientRespBody)
			return response, resHeaders, nil
	}
}

{{if and (ne .ResponseType "") (ne $clientResType "") -}}
{{ range $key, $line := $method.ConvertResponseGoStatements -}}
{{$line}}
{{ end }}

{{end -}}

{{if and (ne .ResponseType "") (ne $shadowClientResType "") -}}
{{ range $key, $line := $method.ConvertShadowResponseGoStatements -}}
{{$line}}
{{ end }}

{{end -}}

{{end -}}
{{end -}}